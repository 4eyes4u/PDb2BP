---
permalink: /poglavlja/3/
layout: page
title: 3. Programiranje korišćenjem kursora
---

Do sada su rezultati naših SQL upita bili kardinalnosti 1. Zbog toga smo mogli da koristimo jednostavnu `SELECT INTO` naredbu za dohvatanje informacija iz rezultata upita. Ukoliko smo sigurni da će rezultat upita biti jedan red, ovakav način programiranja je prihvatljiv. Međutim, ukoliko znamo da se rezultat može sastojati od više redova, potreban nam je drugačiji pristup.

U slučaju da nam je nepoznat broj redova u rezultatu upita, za dohvatanje rezultata možemo iskoristiti mehanizam zasnovan na kursorima. Kursorima je moguće procesirati svaki red rezultata, bez obzira na to koliko redova rezultat sadrži. Kursor je imenovana kontrolna struktura koja se koristi od strane aplikativnog programa da "pokazuje" na specifičan red u okviru uređenog skupa redova.

## 3.1 Rad sa kursorima

Rad sa kursorima se najčešće može opisati kroz naredna četiri koraka:

1. Deklaracija kursora
2. Otvaranje kursora
3. Iteriranje kroz kursor
4. Zatvaranje kursora

### 3.1.1. Deklaracija kursora

Deklaracija kursora se izvodi navođenjem SQL naredbe `DECLARE` čija je sintaksa data u nastavku:

```sql
DECLARE <IME_KURSORA>
CURSOR FOR <UPIT>
[(FOR READ ONLY)|(FOR UPDATE OF <LISTA_ATRIBUTA>)]
[(WITHOUT HOLD)|(WITH HOLD)]
```

Promenljiva `<IME_KURSORA>` mora biti jedinstvena u programu. Vrednost `<UPIT>` predstavlja upit, tj. naredbu `SELECT` za koji se kursor vezuje. Upit ne može da sadrži parametarske oznake, ali može sadržati matične promenljive, s tim da deklaracije matičnih promenljivih koje se koriste u upitu moraju biti pre deklaracije kursora. 

Ukoliko navedemo klauzu `FOR READ ONLY`, time definišemo kursor koji služi samo za čitanje podataka. Ukoliko želimo da se podaci menjaju pomoću kursora, tada se nakon `<UPIT>` navodi klauza `FOR UPDATE OF` za kojom sledi lista imena kolona u rezultatu upita koji se mogu menjati kursorom, odvojeni zapetama.

Kursor se implicitno ograničava samo za čitanje (kažemo da je kursor *čitajući*) ako je ispunjen barem jedan od sledećih uslova:

- Bilo koja `FROM` klauza koja se nalazi u `<UPIT>` sadrži više od jedne tabele ili sadrži pogled koji služi samo za čitanje.

- `<UPIT>` sadrži neku od klauza `DISTINCT`, `VALUES` ili `ORDER BY`.

- `<UPIT>` sadrži agregatne funkcije ili neku od klauza `GROUP BY` ili `HAVING`.

- `<UPIT>` sadrži neki skupovni operator, kao što su `UNION`, `INTERSECT` ili `EXCEPT` sa izuzetkom `UNION ALL`.

Za kursor kažemo da je *brišući* ukoliko nije čitajući. Za kursor kažemo da je *ažurirajući* ukoliko je brišući i kolone koje su proglašene za ažuriranje u klauzi `FOR UPDATE OF` predstavljaju neke od kolona u baznoj tabeli. Za kursor kažemo da je *dvosmisleni* ukoliko je upit dinamički pripremljen i nije navedena nijedna od klauza `FOR READ ONLY` ili `FOR UPDATE OF`.

Navođenjem neke od opcionih klauza `WITHOUT HOLD` ili `WITH HOLD` možemo specifikovati da li će se kursor zatvarati ili ne kao posledica operacije *pohranjivanja* (engl. *commit*). Navođenjem klauze `WITHOUT HOLD` kursor se ne sprečava da bude zatvoren, što je podrazumevano ponašanje. Navođenjem klauze `WITH HOLD` kursor održava resurse kroz različite jedinice posla. Kada budemo diskutovali o transakcijama, definisaćemo preciznije ovo ponašanje.

### 3.1.2. Otvaranje kursora

Otvaranje kursora se izvodi navođenjem SQL naredbe `OPEN` čija je sintaksa data u nastavku:

```sql
OPEN <IME_KURSORA>
[USING <LISTA_MATICNIH_PROMENLJIVIH>]
```

Naredbom `OPEN` se vrši otvaranje kursora i njegovo izvršavanje, zarad dohvatanja redova iz rezultujuće tabele. Promenljiva `<IME_KURSORA>` mora biti deklarisana naredbom `DECLARE` pre samog otvaranja kursora. Kada se izvrši naredba `OPEN`, kursor naziva `<IME_KURSORA>` mora biti u zatvorenom stanju (bilo da je eksplicitno zatvoren ili da je samo deklarisan pre otvaranja).

Ukoliko se kursor otvara za pripremljenu SQL naredbu, navođenjem klauze `USING` možemo uvesti vrednosti koje se koriste za zamenu parametarskih oznaka. U slučaju statičke SQL naredbe, pri deklaraciji kursora, klauza `USING` se može koristiti, upravo iz razloga što statičke SQL naredbe ne mogu imati parametarske oznake.

Nakon otvaranja kursor je pozicioniran ispred prvog reda rezultujuće tabele.

### 3.1.3. Iteriranje kroz kursor

Iteriranje kroz kursor se izvodi navođenjem SQL naredbe `FETCH` čija je sintaksa data u nastavku:

```sql
FETCH <IME_KURSORA>
INTO <LISTA_MATICNIH_PROMENLJIVIH>
```

Naredbom `FETCH` se vrši pozicioniranje kursora na naredni red iz rezultujuće tabele i dodeljuju se vrednosti iz tog reda ciljanim promenljivama. Promenljiva `<IME_KURSORA>` mora biti deklarisana naredbom `DECLARE` pre samog dohvatanja podataka. Dodatno, da bi se izvršila naredba `FETCH`, kursor naziva `<IME_KURSORA>` mora biti u otvorenom stanju.

Klauzom `INTO` se prva vrednost dohvaćenog reda smešta u prvu promenljivu koja je navedena u `<LISTA_MATICNIH_PROMENLJIVIH>`, druga vrednost reda u drugu promenljivu, itd. Ako dođe do greške pri bilo kojoj dodeli vrednosti, ta vrednost se ne dodeljuje promenljivoj, kao ni bilo koja vrednost nakon nje. Sve do tada dodeljene vrednosti ostaju dodeljene.

Otvoreni kursor ima tri moguće pozicije: 

1. Može biti pozicioniran ispred prvog reda.
2. Može biti pozicioniran na nekom redu.
3. Može biti pozicioniran nakon poslednjeg reda.

Kursor može biti samo pozicioniran na nekom redu isključivo primenom naredbe `FETCH`. Ako se kursor pozicionira na poslednjem redu rezultujuće tabele ili iza njega, izvršavanje naredbe `FETCH` ima naredne efekte:

- Vrednost koda za dijagnostiku greške (u našim programima, vrednost u koju se razmota makro `SQLCODE`) postavlja se na vrednost `+100`.

- Kursor se pozicionira nakon poslednjeg reda rezultata.

- Vrednosti se ne dodeljuju matičnim promenljivama.

Ako je kursor pozicioniran ispred prvog reda, izvršavanjem naredbe `FETCH`, kursor se pozicionira na prvi red, i vrednosti se dodeljuju matičnim promenljivama klauzom `INTO`. Ako je kursor pozicioniran na redu koji nije poslednji, izvršavanjem naredbe `FETCH`, kursor se pozicionira na naredni red i vrednosti tog reda se dodeljuju matičnim promenljivama klauzom `INTO`.

Ako je kursor pozicioniran na nekom redu, taj red se naziva *tekući red kursora*. Kursor na koji se referiše u pozicionirajućim naredbama `UPDATE` ili `DELETE` mora biti pozicioniran na nekom redu. Moguće je da se, dolaskom do greške, stanje kursora postavi na nepredvidivo.

### 3.1.4. Zatvaranje kursora

Zatvaranje kursora se izvodi navođenjem SQL naredbe `CLOSE` čija je sintaksa data u nastavku:

```sql
CLOSE <IME_KURSORA>
[WITH RELEASE]
```

Naredbom `CLOSE` se vrši zatvaranje kursora. Ukoliko je rezultujuća tabela kreirana kada je kursor otvoren, ta tabela se uništava. Promenljiva `<IME_KURSORA>` mora biti deklarisana naredbom `DECLARE` pre samog dohvatanja podataka. Dodatno, da bi se izvršila naredba `CLOSE`, kursor naziva `<IME_KURSORA>` mora biti u otvorenom stanju.

Ukoliko se navede opciona klauza `WITH RELEASE`, prilikom zatvaranja kursora se pokušava sa oslobađanjem svih katanaca koji su držani od strane kursora. S obzirom da se katanci mogu držati drugim operacijama ili procesima, ne znači da će biti nužno i oslobođeni zatvaranjem kursora. O katancima će biti više reči u kasnijim poglavljima.

Na kraju jedinice posla, svi kursori koji pripadaju procesu aplikacije i koji su deklarisani bez klauze `WITH HOLD` se implicitno zatvaraju.

## 3.2 Korišćenje kursora za čitanje podataka

Sada smo spremni za rešavanje primera koji zahtevaju upotrebu kursora. Počnimo sa narednim zadacima koji ilustruju čitanje rezultata iz kursora.

> Zadatak 3.1: Napisati C/SQL program koji ispisuje identifikator, oznaku, naziv, broj semestara i broj bodova za svaki od smerova.

Rešenje:

```c
#include <stdio.h>
#include <stdlib.h>

EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION;
sqlint32 d_id;
char d_oznaka[11];
char d_naziv[201];
short d_semestara;
short d_bodovi;
EXEC SQL END DECLARE SECTION;

void is_error(const char* str)
{
    if (SQLCODE < 0)
    {
        printf("SQLCODE %d: %s\n", SQLCODE, str);
        exit(EXIT_FAILURE);
    }
}

int main()
{
    // Konektujemo se na bazu podataka
    EXEC SQL CONNECT TO vstud user student using abcdef;
    is_error("Connect");
    
    // Deklarisemo kursor koji prolazi tabelom smer
    EXEC SQL DECLARE c_smer CURSOR FOR 
        SELECT 
            id_smera, 
            oznaka, 
            naziv, 
            semestara, 
            bodovi 
        FROM 
            smer;
    is_error("Declare cursor");
    
    // Otvaramo kursor, cime se izvrsava upit naveden u deklaraciji
    EXEC SQL OPEN c_smer;
    is_error("Open cursor");

    // Sve dok ima redova u rezultujucoj tabeli
    for(;;)
    {
        // Citamo red po red
        EXEC SQL 
            FETCH 
                c_smer
            INTO 
                :d_id, 
                :d_oznaka, 
                :d_naziv, 
                :d_semestara, 
                :d_bodovi;
        is_error("Fetch cursor");

        // Ako smo stigli do kraja rezultujuce tabele, 
        // izlazimo iz petlje
        if (SQLCODE == 100) 
        {
            break;
        }

        // Inace, stampamo red iz rezultata
        printf("ID:%d   OZNAKA:%s   NAZIV:%.70s   "
            "SEMESTARA:%hd   bodovi:%hd\n", 
            d_id, d_oznaka, d_naziv, d_semestara, d_bodovi);
    }

    // Zatvaramo kursor
    EXEC SQL CLOSE c_smer;
    is_error("Close cursor");

    // Raskidamo konekciju sa bazom podataka
    EXEC SQL CONNECT RESET;
    is_error("Connect reset");
    
    return 0;
}
```

> Zadatak 3.2: Napisati C/SQL program kojim se za uneti broj indeksa studenta ispisuju podaci (naziv predmeta, datum polaganja i ocena) za sve ispite koje je on položio. Nakon toga ispisuje se njegov prosek.

## 3.3 Korišćenje kursora za ažuriranje i brisanje podataka

Kao što smo napomenuli, moguće je korišćenje kursora za ažuriranje ili brisanje redova iz tabela. U slučaju ažuriranja redova, potrebno je deklarisati koje kolone se mogu menjati pri deklaraciji kursora, a zatim koristiti `UPDATE` naredbu oblika:

```sql
UPDATE 
    <TABELA>
SET 
    <KOLONA_1> = <VREDNOST_1>,
    -- ...
    <KOLONA_N> = <VREDNOST_N>
WHERE CURRENT OF <IME_KURSORA>
```

> SQL naredba `UPDATE` koja ažurira podatke u tabeli na osnovu pozicije nekog kursora naziva se *pozicionirajuća* `UPDATE` naredba. 

Očigledno, kolone `<KOLONA_1>`, `...`, `<KOLONA_N>` moraju biti deklarisane u `FOR UPDATE OF` klauzi pri deklaraciji kursora naziva `<IME_KURSORA>`. Takođe, tabela `<TABELA>` mora biti jedina tabela koja se nalazi u `FROM` klauzi kursora. Na ovaj način će upotrebom opisane naredbe `UPDATE` biti ažuriran tekući red kursora.

> Zadatak 3.3: Napisati C/SQL program kojim se za svaki od smerova korisniku postavlja pitanje da li želi da uveća broj bodova za 10. Ako je odgovor potvrdan, vrši se odgovarajuća promena.

```c
#include <stdio.h>
#include <stdlib.h>

EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION;
sqlint32 d_id;
char d_oznaka[11];
char d_naziv[201];
short d_semestara;
short d_bodovi;
EXEC SQL END DECLARE SECTION;

void is_error(const char* str)
{
    if (SQLCODE < 0)
    {
        printf("SQLCODE %d: %s\n", SQLCODE, str);
        exit(EXIT_FAILURE);
    }
}

int main()
{    
    // Odgovor od korisnika
    char c; 

    EXEC SQL CONNECT TO vstud user student using abcdef;
    is_error("Connect");
    
    // Deklarisemo kursor koji prolazi tabelom smer, 
    // kojim zelimo da menjamo atribut bodovi
    EXEC SQL DECLARE c_smer CURSOR FOR 
        SELECT 
            id_smera, 
            oznaka, 
            naziv, 
            semestara, 
            bodovi 
        FROM 
            smer
        FOR UPDATE OF bodovi; // Na ovaj nacin najavljujemo 
                              // da cemo vrsiti promenu kolone "bodovi"
    is_error("Declare cursor");
    
    EXEC SQL OPEN c_smer;
    is_error("Open cursor");

    for(;;)
    {
        EXEC SQL 
            FETCH 
                c_smer
            INTO 
                :d_id, 
                :d_oznaka, 
                :d_naziv, 
                :d_semestara, 
                :d_bodovi;
        is_error("Fetch cursor");

        if (SQLCODE == 100)
        {
            break;
        }
        
        printf("Da li zelite da povecate broj bodova za smer %.70s za 10?\n"
            "Unesite d/D ili n/N. \n", d_naziv);
        scanf("%c", &c);

        // Da bismo procitali i znak za novi red
        getchar();
        
        // Ukoliko korisnik zeli izmenu
        if (c == 'd' || c == 'D')
        {
            EXEC SQL 
                UPDATE 
                    smer
                SET 
                    bodovi = bodovi + 10
                WHERE CURRENT OF c_smer; // Na ovaj nacin kazemo da zelimo izmenu 
                                         // nad trenutnim redom u kursoru c_smer
            is_error("Update");
            
            EXEC SQL 
                SELECT 
                    bodovi 
                INTO 
                    :d_bodovi
                FROM 
                    smer
                WHERE 
                    id_smera = :d_id;
            is_error("Select into");
            
            printf("Broj bodova je sada %hd\n", d_bodovi);
        }
    }

    EXEC SQL CLOSE c_smer;
    is_error("Close cursor");
    
    EXEC SQL CONNECT RESET;
    is_error("Connect reset");
    
    return 0;
}
```

U slučaju brisanja redova pomoću kursora, nije potrebno deklarisati koje kolone se mogu brisati kao što je to bio slučaj sa ažuriranjem. Potrebno je samo da tabela `<TABELA>` bude jedina tabela koja se nalazi u `FROM` klauzi upita kursora naziva `<IME_KURSORA>`, da bi se mogla koristiti `DELETE` naredba oblika:

```sql
DELETE FROM <IME_TABELE>
WHERE CURRENT OF <IME_KURSORA>
```

> SQL naredba `DELETE` koja ažurira podatke u tabeli na osnovu pozicije nekog kursora naziva se *pozicionirajuća* `DELETE` naredba. 

> Zadatak 3.4: Napisati C/SQL program kojim se za sve studente smera Informatika briše prvi položen ispit (ukoliko ima položenih ispita tog studenta).

```c
#include <stdio.h>
#include <stdlib.h>

EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION;
sqlint32 indeks;
char datum[11];
EXEC SQL END DECLARE SECTION;

void is_error(const char* str)
{
    if (SQLCODE < 0)
    {
        printf("SQLCODE %d: %s\n", SQLCODE, str);
        exit(EXIT_FAILURE);
    }
}

int main()
{
    // Brojac obrisanih redova
    int i = 0;

    EXEC SQL CONNECT TO vstud USER student USING abcdef;
    is_error("Connect");
    
    EXEC SQL DECLARE prvi_ispit CURSOR FOR 
        WITH pomocna AS (
            SELECT
                i.indeks, 
                min(coalesce(datum_usmenog, datum_pismenog)) datum_prvog
            FROM
                ispit i JOIN
                dosije d ON d.indeks = i.indeks join
                smer s ON s.id_smera = d.id_smera
            WHERE
                s.oznaka = 'I' AND
                ocena > 5 AND
                status_prijave = 'o'
            GROUP BY
                i.indeks
        )

        SELECT 
            i.indeks, 
            coalesce(datum_usmenog, datum_pismenog)
        FROM 
            ispit i
        WHERE EXISTS (
            SELECT 
                *
            FROM 
                pomocna po 
            WHERE 
                po.indeks = i.indeks AND
                po.datum_prvog = coalesce(i.datum_usmenog, i.datum_pismenog)
            );
    is_error("Declare cursor");
    
    EXEC SQL OPEN prvi_ispit;
    is_error("Open cursor");

    for(;;)
    {
        EXEC SQL 
            FETCH 
                prvi_ispit
            INTO 
                :indeks, 
                :datum;
        is_error("Fetch cursor");

        if (SQLCODE == 100) 
        {
            break;
        }

        printf("Student sa brojem indeksa %d ima datum polaganja prvog ispita %s...\n"
            "Izbrisacemo to iz tabele ispit!\n", indeks, datum);

        // Uvecavamo brojac za jedan
        ++i;

        EXEC SQL 
            DELETE FROM ispit 
            WHERE CURRENT OF prvi_ispit; // Na ovaj nacin kazemo da zelimo da obrisemo 
                                         // trenutni red u kursoru prvi_ispit
        is_error("Delete");
    }

    printf("\n\nObrisali smo %d redova.\n", i);

    EXEC SQL CLOSE prvi_ispit;
    is_error("Close cursor");
    
    EXEC SQL CONNECT RESET;
    is_error("Connect reset");
    
    return 0;
}
```

## 3.4 Ugnež\djeni kursori

Do sada smo videli kako možemo koristiti kursore za upravljanje potencijalno višim brojem redova u rezultatu upita. Obrada ovih redova je do sada obuhvatala jednostavno procesiranje podataka, poput ispisivanja na standardni izlaz, uz eventualne transformacije ili ažuriranje ili brisanje podataka na koje pokazuje kursor.

Međutim, šta raditi ukoliko je potrebno da za svaki red rezultata jednog upita izvršimo akciju nad rezultatom nekog drugog upita? Da li nam kursori u ovakvim situacijama mogu pomoći? Odgovor je potvrdan zbog činjenice da je kursore moguće ugnežđavati. Tipičan tok rada podrazumeva naredne korake u slučaju dva kursora od kojih je jedan (unutrašnji) ugnežđen u drugi (spoljašnji):

1. Deklaracija spoljašnjeg kursora.

2. Deklaracija unutrašnjeg kursora.

3. Otvaranje spoljašnjeg kursora.

4. Dohvatanje jednog po jednog reda spoljašnjeg kursora. Za svaki dohvaćeni red u spoljašnjem kursoru:

   1. Obrada dohvaćenih podataka spoljašnjeg kursora.

   2. Otvaranje unutrašnjeg kursora.

   3. Dohvatanje jednog po jednog reda unutrašnjeg kursora. Za svaki dohvaćeni red u unutrašnjem kursoru:

      1. Obrada dohvaćenih podataka unutrašnjeg kursora.

   4. Zatvaranje unutrašnjeg kursora.

5. Zatvaranje spoljašnjeg kursora.

Naredna dva zadatka ilustruju rad sa ugnežđenim kursorima.

> Zadatak 3.5: Napisati C/SQL program kojim se formira izveštaj o studentima koji su padali neki ispit koji sadrži sledeće informacije: ime, prezime i broj indeksa. Za svaki smer formirati posebnu sekciju izveštaja sa odgovarajućim zaglavljem. Sadržaj svake sekcije urediti po broju indeksa.

```c
#include <stdio.h>
#include <stdlib.h>

EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION;
sqlint32 id_smera;
char naziv[201];
sqlint32 indeks;
char ime[21];
char prezime[21];
EXEC SQL END DECLARE SECTION;

void is_error(const char* err)
{
    if (SQLCODE < 0)
    {
        printf("SQLCODE %d: %s\n\n", SQLCODE, err);
        exit(EXIT_FAILURE);
    }
}

int main()
{
    EXEC SQL CONNECT TO vstud;  
    is_error("Konekcija na bazu");
    
    EXEC SQL DECLARE smerovi CURSOR FOR 
        SELECT 
            id_smera, 
            naziv
        FROM 
            smer
        ORDER BY 
            id_smera;
    is_error("Deklaracija kursora - smerovi");
    
    EXEC SQL DECLARE padaliIspit CURSOR FOR 
        SELECT 
            indeks, 
            ime, 
            prezime
        FROM 
            dosije d 
        WHERE 
            d.id_smera = :id_smera AND
            EXISTS (
                SELECT 
                    * 
                FROM 
                    ispit
                WHERE 
                    indeks = d.indeks AND
                    ocena = 5 AND
                    status_prijave = 'o'
            )
        ORDER BY 
            indeks;
    is_error("Deklaracija kursora - padaliIspit");
    
    /////////////////////////////////////
    // Pocetak obrade spoljasnjeg kursora

    EXEC SQL OPEN smerovi;
    is_error("Otvaranje kursora - smerovi");

    while(1)
    {
        EXEC SQL 
            FETCH 
                smerovi
            INTO 
                :id_smera, 
                :naziv;
        is_error("Dohvatanje podataka iz kursora - smerovi");

        if(SQLCODE == 100)
        {
            break;
        }
        
        // Stampamo sekciju za smer
        printf("\n*****************\nStudenti sa smera %d: %s!\n*****************\n",
            id_smera, naziv);
        
        /////////////////////////////////////
        // Pocetak obrade unutrasnjeg kursora

        EXEC SQL OPEN padaliIspit;
        is_error("Otvaranje kursora - padaliIspit");
        
        while(1)
        {
            EXEC SQL 
                FETCH 
                    padaliIspit
                INTO 
                    :indeks, 
                    :ime, 
                    :prezime;
            is_error("Dohvatanje podataka iz kursora - padaliIspit");

            if(SQLCODE == 100)
            {
                break;
            }
            
            // Stampamo informacije o studentu
            printf("Student %s %s sa brojem indeksa %d\n", ime, prezime, indeks);    
        }
        
        EXEC SQL CLOSE padaliIspit;
        is_error("Zatvaranje kursora - padaliIspit");
        
        // Kraj obrade unutrasnjeg kursora
        //////////////////////////////////
    }

    EXEC SQL CLOSE smerovi;
    is_error("Zatvaranje kursora - padaliIspit");

    // Kraj obrade spoljasnjeg kursora
    //////////////////////////////////

    EXEC SQL CONNECT RESET;
    is_error("Connect reset");
    
    return 0;
}
```

> Zadatak 3.6: Napisati C/SQL program kojim se za svaki smer pronalazi student koji ima najviše položenih ESPB bodova. Zatim u tabeli ISPIT u napomeni koja se odnosi na poslednji položeni ispit tog studenta zapisuje 'Ovo je student koji ima najvise polozenih kredita na svom smeru'.

```c
#include <stdio.h>
#include <stdlib.h>

EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION;
short suma; 
sqlint32 id_smera;
sqlint32 indeks;
char datum[11];
EXEC SQL END DECLARE SECTION;

void is_error(const char* err)
{
    if (SQLCODE < 0)
    {
        printf("SQLCODE %d: %s\n\n", SQLCODE, err);
        exit(EXIT_FAILURE);
    }
}

int main()
{
    EXEC SQL CONNECT TO vstud;  
    is_error("Konekcija na bazu");
    
    EXEC SQL DECLARE najvisePolozenih CURSOR FOR 
        WITH pomocna AS (
            SELECT 
                d.id_smera, 
                d.indeks, 
                sum(p.bodovi) suma
            FROM 
                dosije d JOIN
                ispit i ON i.indeks = d.indeks JOIN
                predmet p ON p.id_predmeta = i.id_predmeta
            WHERE 
                ocena > 5 AND
                status_prijave='o'
            GROUP BY 
                d.id_smera, 
                d.indeks
        )
            
        SELECT 
            pom.suma, 
            d.indeks, 
            pom.id_smera    
        FROM 
            pomocna pom JOIN
            dosije d ON d.indeks = pom.indeks 
        WHERE 
            pom.suma IN (
                SELECT 
                    max(suma) 
                FROM 
                    pomocna pom1 
                WHERE 
                    pom1.id_smera = pom.id_smera
            )
        ORDER BY 
            id_smera;
    is_error("Deklaracija kursora - najvisePolozenih");
    
    EXEC SQL DECLARE poslednji_ispit CURSOR FOR 
        WITH pomocna AS (
            SELECT 
                i.indeks, 
                max(coalesce(datum_usmenog, datum_pismenog)) datum_prvog
            FROM 
                ispit i JOIN
                dosije d ON d.indeks = i.indeks
            WHERE 
                ocena > 5 AND
                status_prijave = 'o'
            GROUP BY
                i.indeks
        )

        SELECT
            i.indeks
        FROM
            ispit i
        WHERE 
            i.indeks = :indeks AND
            EXISTS (
                SELECT 
                    * 
                FROM 
                    pomocna po 
                WHERE 
                    po.indeks = i.indeks AND
                    po.datum_prvog = coalesce(i.datum_usmenog, i.datum_pismenog)
            )
        FOR UPDATE OF napomena;
    is_error("Deklaracija kursora - poslednji_ispit");
    
    EXEC SQL OPEN najvisePolozenih;
    is_error("Otvaranje kursora - najvisePolozenih");

    while(1)
    {
        EXEC SQL 
            FETCH 
                najvisePolozenih                
            INTO 
                :suma, 
                :indeks, 
                :id_smera;
        is_error("Dohvatanje podataka iz kursora - najvisePolozenih");

        if(SQLCODE == 100)
        {
            break;
        }
        
        // Stampamo informaciju o studentu koji ima najvise kredita na smeru
        printf("Student sa brojem indeksa %d na smeru %d ima polozeno %d bodova!\n", 
            indeks, id_smera, suma);
        
        EXEC SQL OPEN poslednji_ispit;
        is_error("Otvaranje kursora - poslednji_ispit");
        
        while(1)
        {
            EXEC SQL 
                FETCH 
                    poslednji_ispit
                INTO 
                    :indeks, 
                    :datum;
            is_error("Dohvatanje podataka iz kursora - poslednji_ispit");

            if(SQLCODE == 100)
            {
                break;
            }
            
            EXEC SQL 
                UPDATE 
                    ispit
                SET 
                    napomena = 'Ovo je student koji ima najvise polozenih kredita na svom smeru'
                WHERE CURRENT OF poslednji_ispit;
            is_error("Azuriranje tabele ispit");
        }
        
        EXEC SQL CLOSE poslednji_ispit;
        is_error("Zatvaranje kursora - poslednji_ispit");
    }

    EXEC SQL CLOSE najvisePolozenih;
    is_error("Zatvaranje kursora - najvisePolozenih");

    EXEC SQL CONNECT RESET;
    is_error("Diskonekcija sa baze");
    
    return 0;
}
```

## 3.5 Zadaci za vežbu

> Zadatak 3.7: Napisati C/SQL program koji ispisuje sva ženska imena koja postoje među studentima (zajedno sa brojem pojavljivanja) u opadajućem poretku.

> Zadatak 3.8: Napisati C/SQL program koji ispisuje za svakog studenta ime, prezime, poslednji položeni ispit (naziv predmeta koji je položen), kao i datum polaganja tog ispita.

> Zadatak 3.9: Napisati C/SQL program koji se za sve studente smera Informatika ažurira u tabeli ISPIT prvi položen ispit (ukoliko ima položenih ispita za tog studenta) tako što povećava ocenu za 1 (ukoliko je ocena bila 5 ili 10 ostavlja je nepromenjenu).

> Zadatak 3.10: Napisati C/SQL program koji ispisuje sve napomene koje se nalaze u tabeli ISPIT, navodeći i broj indeksa studenata.

> Zadatak 3.11: Napisati C/SQL program kojim se sa standardnog ulaza unosi ime smera, a zatim se ispisuje 10 studenata tog smera koji su najviše padali na ispitima tokom studija. Izdvojiti ime, prezime, broj indeksa i broj padova tokom studija.

> Zadatak 3.12: Napisati C/SQL program koji ispisuje za svakog studenta ime, prezime, poslednji položeni ispit (tj. naziv predmeta koji je položen), kao i datum polaganja tog ispita.

> Zadatak 3.13: Napisati C/SQL program koji za studenta čiji se broj indeksa zadaje sa standardnog ulaza, ispisuje naziv predmeta, datum polaganja, ocenu, broj bodova na pismenom i broj bodova na usmenom delu ispita za svaki ispit koji je student položio. Nakon toga ispisuje se prosečna ocena studenta.

> Zadatak 3.14: Napisati C/SQL program kojim se omogućava nastavniku da unese naziv predmeta, godinu roka i oznaku roka. Za svako polaganje datog predmeta u datom ispitnom roku ponuditi nastavniku mogućnost da izmeni ocenu koju je student osvojio. Ispisati informacije o indeksu, imenu i prezimenu studenta kao i ocenu koju je dobio, pa zatražiti od nastavnika novu ocenu. Nakon unosa nove ocene, obavestiti nastavnika o uspešnosti izmene i preći na naredno polaganje (ukoliko ih ima više).

> Zadatak 3.15: Napisati C/SQL program kojim se brišu sva uspešna polaganja ispita iz barem trećeg pokušaja za studente koji su upisivali najviše N godina, gde se vrednost za N unosi sa standardnog ulaza.

> Zadatak 3.16: Napisati C/SQL program kojim se prvo unosi identifikator predmeta sa standardnog ulaza. Za taj predmet se zatim korisniku nudi da li želi da obriše uslovne predmete za taj predmet i to tako što se za svaki uslovni predmet nudi da li korisnik hoće da ga obriše ili ne. Odgovori su 'D' ili 'N'. Ukoliko je odgovor 'D', u tabeli `USLOVNI_PREDMET` briše se željeni red koji se odnosi na predmet za koje je pitanje postavljeno.

> Zadatak 3.17: Napisati C/SQL program kojim se, za svakog studenta koji se upisao u godini koja se učitava sa standardnog ulaza, ispisuju podaci o imenu, prezimenu i prosečnoj oceni, a zatim se ispisuju informacije o položenim ispitima i to: naziv predmeta, ocena i datum polaganja.

> Zadatak 3.18: Napisati C/SQL program koji ispisuje izveštaj za svaki predmet o njegovim uslovnim predmetima. Za svaki predmet ispisati informacije o identifikatoru predmeta i njegovom nazivu. Svaka sekcija koja ispisuje informacije o uslovnim predmetima treba da izlistava identifikator i naziv uslovnih predmeta za tekući predmet za koji se pravi sekcija, pri čemu se prikazuju informacije samo o onim uslovnim predmetima za koje postoji polaganje sa ocenom 10 na osnovnim studijama čiji je datum polaganja bio pre 2011. godine. Stavke sekcije prikazati razdvojene zapetom, i svaki uslovni predmet prikazati u posebnom redu.

> Zadatak 3.19: Napisati C/SQL program koji za svaki ispitni rok ispisuje njegov naziv i broj uspešnih polaganja za svaku ocenu u tom ispitnom roku. Nakon ispisivanja informacija o ispitnom roku, ponuditi korisniku da izbriše informacije o polaganim ispitima u tom roku. Ukoliko korisnik želi da obriše te podatke, prvo izlistati podatke o indeksu, identifikatoru predmeta, godini roka, oznaci roka i datumu polaganja (ako postoji) za svako polaganje koje se briše. Na kraju brisanja polaganja u jednom ispitnom roku, ispisati ukupan broj obrisanih redova.
    